#BlueJ class context
comment0.target=Sorter
comment0.text=\n\ \ The\ Sorter\ class\ includes\ the\ algorithsm\ for\ selectionSort,\n\ \ mergeSort,\ insertionSort,\ and\ quickSort.\n\ \ @author\ Caden\ Lin\ \n\ \ @version\ March\ 9,\ 2021\ \n\ \ @\n
comment1.params=args
comment1.target=void\ main(java.lang.String[])
comment1.text=\n\ main\ method\ instantiates\ a\ sorter\ instance\n\ Usage\:\ called\ directly\ by\ the\ IDE\ or\ when\ Java\ is\ launched\ \n\ ------------------------------------------\n\ Creates\ a\ Sorter\ object,\ but\ calls\ no\ methods\ from\ Sorter\ \n\ because\ the\ GUI\ SortDisplay\ calls\ sort\ methods\ in\ Sorter\n\ \n\ @param\ args\ an\ array\ of\ arguments\ for\ legacy\ command\ line\n\ \ \ \ \ \ \ \ \ \ \ \ \ \ the\ values\ are\ not\ used\n
comment10.params=a
comment10.target=void\ quicksort(java.lang.Comparable[])
comment10.text=\ \ \ \ \ \n\ Method\:\ quicksort()\n\ Usage\:\ sorter.quicksort(inputArray)\n\ -------------------------------------\n\ quicksort()\ does\ not\ actual\ do\ the\ sorting,\n\ just\ calls\ quicksortHelp\ with\ parameters\ (a,\ 0,\ a.length-1),\n\ which\ does\ the\ actual\ quick\ sorting\n\ \n\ Postcondition\:\ a[lowIndex]\ to\ a[highIndex]\ are\ in\ increasing\ order\n\ @param\ a\ -\ array\ of\ comparable\ elements\ to\ be\ sorted\ with\ quick\ sort\n
comment11.params=a\ lowIndex\ highIndex
comment11.target=void\ quicksortHelp(java.lang.Comparable[],\ int,\ int)
comment11.text=\n\ Method\:\ quicksortHelp()\n\ Usage\:\ quicksortHelp(a,\ low,\ high)\n\ ------------------------------------------\n\ Quick\ soritng\ is\ a\ recursive\ sorting\ algorithm\ that\ sets\ a\ \n\ pivot\ point\ (lowIndex\ in\ this\ case)\n\ and\ calls\ partition\ which\ rough\ sort\:\ puts\ every\ element\ less\ than\ pivot\ l\n\ eft\ of\ pivot,\ and\ every\ element\ bigger\ than\ pivot\ right\ of\ pivot\n\ then\ quicksortHelp\ is\ called\ on\ the\ sections\ left\ &\ right\ of\ the\ pivot\ point\n\ \n\ Base\ case\:\ section\ of\ the\ array\ given\ by\ low\ &\ highIndex\ has\ 1\ element\ (high\ <\=\ low),\ \n\ \ \ \ \ \ \ \ \ which\ is\ "sorted"\ by\ definition,\ therefore\ nothing\ is\ done\ to\ it\n\ Recursive\ reduction\:\ the\ element\ at\ lowIndex\ is\ sorted\ as\ the\ pivot\ using\ partition()\n\ and\ the\ index\ where\ it\ lands\ is\ returned.\n\ \ \ \ \ \ \ \ \ The\ array\ is\ then\ divided\ from\ (low,pivot-1)\ &\ (pivot+1,high)\ \n\ \ \ \ \ \ \ \ \ because\ index\ pivot\ is\ already\ sorted\ \n\ \ \ \ \ \ \ \ \ and\ quicksortHelp\ is\ used\ again\ on\ sections\ left\ &\ right\ of\ the\ pivot\ element\n\ \n\ Postcondition\:\ a[lowIndex]\ to\ a[highIndex]\ are\ in\ increasing\ order\n\ @param\ a\ -\ array\ of\ comparable\ elements\ to\ be\ sorted\ with\ quick\ sort\n\ @param\ lowIndex\ -\ beginning\ index\ of\ section\ of\ array\ to\ be\ sorted\n\ @param\ highIndex\ -\ ending\ index\ of\ section\ of\ array\ to\ be\ sorted\n
comment12.params=a\ lowIndex\ highIndex
comment12.target=int\ partition(java.lang.Comparable[],\ int,\ int)
comment12.text=\n\ Method\ partition\n\ Usuage\:\ int\ pivotIndex\ \=\ partition(a,\ lowIndex,\ highIndex)\n___________________________________________________________\n\nReturns\ the\ index\ of\ the\ pivot\ element\ defined\ as\ follows\:\n\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ All\ elements\ on\ the\ left\ side\ of\ the\ pivot\ (from\ lowIndex)\n\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ are\ less\ than\ or\ equal\ to\ the\ pivot.\n\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ All\ elements\ on\ the\ right\ side\ of\ the\ pivot\ (through\ highIndex)\n\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ are\ greater\ than\ or\ equal\ to\ the\ pivot.\n\ The\ computation\ is\ performed\ in\ place.\n\ @param\ a\ the\ array\ to\ partion\n\ @param\ lowIndex\ is\ the\ index\ of\ the\ start\ of\ the\ part\ of\ array\ a\ to\ consider\n\ @param\ highIndex\ is\ the\ index\ of\ the\ end\ of\ the\ part\ of\ array\ a\ to\ consider\n\ @return\ the\ index\ of\ the\ pivot\ element\ in\ array\ a\n
comment2.params=
comment2.target=Sorter()
comment2.text=\n\ Constructor\:\ Sorter()\n\ Useage\:\ \ Sorter\ aSorter\ \=\ new\ Sorter()\n\ ________________________________________\n\ constructor\ for\ Sorter\ objects.\ \ Creates\ a\ new\ display,\ which\ controls\n\ all\ of\ the\ sorting\ by\ means\ of\ call-backs\ to\ this\ class.\n
comment3.params=a\ startIndex
comment3.target=int\ indexOfMin(java.lang.Comparable[],\ int)
comment3.text=\n\ Method\:\ indexOfMin()\n\ Usage\:\ Finds\ the\ minimum\ element\ in\ an\ array\ starting\ from\ a\ given\ index\n\ through\ a\ linear\ search\ of\ the\ array.\ \n\ @param\ a\ the\ array\ to\ search\n\ @param\ startIndex\ the\ index\ to\ start\ the\ search\ from\ \n\ @return\ the\ minimum\ element\ in\ the\ array\ after\ the\ given\ index\ \n
comment4.params=a
comment4.target=void\ selectionSort(java.lang.Comparable[])
comment4.text=\n\ Method\:\ selectionSort()\n\ Usage\:\ Sorts\ an\ array\ using\ the\ selection\ sort\ method.\ \n\ In\ selection\ sort,\ the\ array\ is\ divided\ into\ a\ sorted\ and\ an\ \n\ unsorted\ portion.\ With\ each\ iteration,\ the\ minimum\ element\ \n\ in\ the\ unsorted\ array\ is\ found\ and\ moved\ to\ the\ end\ of\ the\ sorted\ subarray,\n\ increasing\ the\ size\ of\ the\ sorted\ portion.\ The\ program\ continues\n\ until\ the\ entire\ array\ is\ sorted.\n\ @postcondition\ the\ array\ is\ sorted\ in\ ascending\ order\ \n\ @param\ a\ the\ array\ to\ search\n
comment5.params=a\ nextIndex
comment5.target=void\ insert(java.lang.Comparable[],\ int)
comment5.text=\n\ Method\:\ insert()\n\ Usage\:\ Moves\ a\ given\ element\ to\ its\ proper,\ sorted\ position\ \n\ in\ the\ array.\ The\ element\ at\ the\ specified\ index\ is\ compared\ to\ \n\ each\ element\ in\ the\ sorted\ array\ (all\ the\ elements\ to\ the\ left),\n\ until\ its\ appropriate\ location\ is\ found,\ with\ the\ elements\ in\ the\ \n\ sorted\ array\ shifting\ to\ the\ right\ with\ each\ comparison.\n\ @precondition\ all\ elements\ to\ the\ left\ of\ the\ specified\ index\ \n\ are\ sorted\ in\ ascending\ order\n\ @postcondition\ the\ specified\ element\ has\ been\ sorted\ properly\ \n\ @param\ a\ the\ array\ to\ search\n\ @param\ nextIndex\ the\ index\ of\ the\ element\ to\ sort\ \n
comment6.params=a
comment6.target=void\ insertionSort(java.lang.Comparable[])
comment6.text=\n\ Method\:\ insertionSort()\n\ Usage\:\ Sorts\ the\ array\ using\ insertion\ sort.\ \n\ The\ array\ is\ divided\ into\ a\ sorted\ and\ an\ unsorted\ portion.\ \n\ With\ each\ iteration,\ the\ first\ element\ in\ the\ unsorted\ portion\ is\ compared\ \n\ to\ the\ elements\ in\ the\ sorted\ portion\ until\ its\ correct\ location\ is\ found.\ \n\ With\ each\ comparison,\ the\ elements\ of\ the\ sorted\ portion\ slide\ to\ the\ \n\ right,\ creating\ a\ hole\ for\ the\ new\ element\ to\ enter\ at\ the\ end.\ \n\ @postcondition\ the\ elements\ are\ sorted\ in\ ascending\ order\ \n\ @param\ a\ the\ array\ to\ search\n\ \n
comment7.params=a
comment7.target=void\ mergesort(java.lang.Comparable[])
comment7.text=\n\ Method\:\ mergesort()\n\ Usage\:\ Sorts\ the\ array\ using\ mergesort.\n\ Mergesort\ is\ a\ divide\ and\ conquer\ algorithm\ that\ \n\ continuously\ divides\ the\ array\ in\ half\ until\ the\ arrays\ \n\ are\ of\ size\ 1\ (and\ therefore\ sorted).\ Then,\ the\ arrays\ of\ \n\ size\ one\ are\ merged\ together\ in\ the\ appropriate\ order,\ and\ \n\ then\ these\ arrays\ of\ size\ \n\ two\ are\ merged\ together\ with\ other\ arrays\ of\ size\ two,\ \n\ such\ that\ they\ are\ also\ sorted.\ This\ process\ continues\ \n\ until\ all\ the\ subarrays\ merge\ together.\ \n\ @postcondition\ the\ elements\ are\ sorted\ in\ ascending\ order\ \n\ @param\ a\ the\ array\ to\ search\n\ \n
comment8.params=a\ lowIndex\ highIndex
comment8.target=void\ mergesortHelp(java.lang.Comparable[],\ int,\ int)
comment8.text=\n\ Method\:\ mergesortHelp()\n\ Usage\:\ The\ mergesortHelp\ method\ is\ helper\ method\ for\ mergesort.\ \n\ Mergesort\ help\ recursively\ divides\ an\ array\ into\ two\ subarrays\ \n\ until\ the\ subarrays\ are\ of\ size\ 1.\ Then,\ these\ subarrays\ are\ \n\ recursively\ merged\ together\ such\ that\ they\ are\ sorted\ \n\ in\ ascending\ order.\n\ @postcondition\ the\ array\ is\ sorted\ in\ ascending\ order\ from\ \n\ lowIndex\ to\ highIndex.\ \n\ @param\ a\ the\ array\ to\ search\n\ @param\ lowIndex\ the\ lower\ index\ to\ begin\ the\ sort\ at\n\ @param\ highIndex\ the\ upper\ index\ to\ end\ the\ sort\ at\ \n
comment9.params=a\ lowIndex\ midIndex\ highIndex
comment9.target=void\ merge(java.lang.Comparable[],\ int,\ int,\ int)
comment9.text=\n\ method\ merge()\n\ Useage\:\ merge(inputArray,\ lowIndex,\ midIndex,\ highIndex)\n_______________________________________________\n\ Merges\ the\ two\ halves\ of\ the\ input\ array\ into\ one.\ \ The\ method\ assumes\n\ that\ each\ half\ of\ the\ input\ array\ is\ sorted\ as\ follows\:\n\ \n\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ a[lowIndex]\ to\ a[midIndex]\ are\ in\ increasing\ order.\n\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ a[midIndex\ +\ 1]\ to\ a[highIndex]\ are\ in\ increasing\ order.\n\ The\ method\ creates\ an\ array\ to\ hold\ the\ output.\ \ It\ then\ establishes\ \n\ two\ pointers\ into\ the\ two\ halves\ of\ the\ input\ array.\ \ The\ values\ at\ the\n\ pointer\ locations\ are\ compared,\ and\ the\ smallest\ is\ added\ to\ the\ output\n\ array.\ \ The\ corresponding\ pointer\ is\ then\ increased\ by\ one.\ \ In\ the\ event\n\ either\ half\ becomes\ empty,\ the\ remaining\ values\ are\ copied\ to\ the\ output\n\ array.\n\ Postcondition\:\ a[lowIndex]\ to\ a[highIndex]\ are\ in\ increasing\ order.\n\n\ @param\ a\ is\ the\ input\ array\ of\ Comparable\ values\n\ @param\ lowIndex\ is\ the\ index\ into\ the\ array\ a\ corresponding\ to\ the\ beginning\n\ \ \ \ \ \ \ \ of\ the\ first\ half\ of\ the\ array\ to\ merge\n\ @param\ midIndex\ is\ the\ index\ of\ the\ last\ value\ in\ the\ first\ half\ of\ the\ array\n\ @param\ highIndex\ is\ the\ index\ of\ the\ last\ value\ in\ the\ second\ half\ of\ the\ array\n
numComments=13
