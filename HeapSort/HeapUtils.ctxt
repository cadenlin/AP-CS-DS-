#BlueJ class context
comment0.target=HeapUtils
comment0.text=\n\ The\ HeapUtils\ class\ contains\ the\ methods\ needed\ to\ perform\ HeapSort,\ \n\ which\ converts\ a\ complete\ binary\ tree\ given\ in\ array\ form\ into\ a\ max\ heap.\ \n\ This\ is\ done\ by\ first\ converting\ the\ elements\ of\ the\ array\ into\ a\ max\ heap,\ which\ \n\ is\ a\ complete\ binary\ tree\ where\ each\ node\ has\ a\ value\ greater\ than\ both\ of\ its\ \n\ children.\ \n\ \n\ Then,\ the\ node\ at\ the\ top\ of\ the\ tree\ (the\ greatest\ value),is\ moved\ to\ the\ end\ of\ the\ array\ \n\ as\ it\ is\ swapped\ with\ the\ last\ node\ in\ the\ tree.\ The\ heapSize\ is\ then\ reduced\ by\ 1.\ \n\ The\ remaining\ tree,\ excluding\ the\ previous\ root,\ is\ turned\ into\ a\ max\ heap\ again,\ bringing\ the\ \n\ next\ greatest\ value\ to\ the\ top\ of\ the\ tree.\ \n\ This\ step\ is\ repeated,\ meaning\ the\ root\ of\ the\ tree\ is\ continually\ added\ to\ the\ end\ of\ the\ tree\ \n\ and\ the\ next\ greatest\ value\ is\ bubbled\ up\ to\ the\ top\ of\ the\ tree,\ \n\ decrementing\ the\ size\ of\ the\ heap\ by\ 1.\ \n\ Once\ the\ size\ of\ the\ heap\ is\ one,\ all\ the\ values\ in\ the\ array\ should\ be\ in\ ascending\ order,\ and\ \n\ the\ heapSort\ will\ be\ completed.\ \n\ \n\ \n\ The\ class\ also\ contains\ the\ remove\ and\ insert\ methods,\ which\ delete\ and\ \n\ insert\ an\ element\ into\ a\ heap\ while\ maintaing\ the\ heap\ structure\ and\ heap\ property.\n\ \n\n\ @author\ Caden\ Lin\ \n\ @version\ Jan\ 25\ 2020\ \n
comment1.params=
comment1.target=HeapUtils()
comment1.text=\n\ Constructor\ for\ objects\ of\ class\ HeapUtils\n
comment2.params=heap\ index\ heapSize
comment2.target=void\ heapify(java.lang.Comparable[],\ int,\ int)
comment2.text=\ The\ heapify\ method\ heapifies\ a\ complete\ binary\ tree\ (given\ in\ array\ form),\n\ which\ means\ that\ it\ takes\ in\ an\ array\ that\ contains\ the\ heap\ data\ \n\ and\ rearranges\ the\ elements\ such\ that\ they\ represent\ a\ max\ heap.\ \ \n\ The\ tree\ must\ follow\ the\ heap\ structure,\ meaning\ it\ is\ a\ complete\ binary\ tree,\ \n\ and\ must\ follow\ the\ max\ heap\ property,\ meaning\ that\ any\ parent\ node\ is\ larger\ tan\ \n\ both\ of\ its\ child\ nodes.\ \n\ \n\ The\ time\ complexity\ is\ O(logn).\ \n\ \n\ @precondition\ heap\ is\ an\ array\ that\ contains\ the\ heap\ data\ for\ a\ complete\ binary\ tree\n\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ the\ left\ and\ right\ subtrees\ of\ the\ root\ that\ is\ called\ must\ be\ max\ heaps\n\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ heapSize\ is\ less\ than\ the\ length\ of\ heap\ \n\ @postcondition\ the\ elements\ of\ heap\ have\ been\ rearranged\ such\ that\ heap\ \n\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ now\ contains\ the\ heap\ data\ for\ a\ max\ heap\n\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ heapSize\ is\ unchanged\ \n\ \n\n\ @param\ heap\ the\ array\ that\ represents\ the\ complete\ binary\ team\ that\ is\ \n\ to\ be\ rearranged\ \n\ @param\ index\ the\ root\ of\ the\ tree\ that\ is\ being\ heapified\ \n\ @param\ heapSize\ the\ size\ of\ the\ heap\ \n\ \n
comment3.params=heap\ heapSize
comment3.target=void\ buildHeap(java.lang.Comparable[],\ int)
comment3.text=\ The\ buildHeap\ method\ heapifies\ every\ nonleaf\ node\ in\ a\ complete\ binary\ tree\ \n\ \ (given\ in\ array\ form),\ turning\ the\ tree\ into\ a\ max\ Heap.\ It\ begins\ at\ the\ last\ \n\ \ nonleaf\ node,\ which\ has\ index\ n/2\ (where\ n\ is\ the\ total\ number\ of\ nodes\ in\ the\ tree)\n\ \ and\ then\ undergoes\ a\ backwards\ level\ order\ traversal,\ heapifying\ every\ node\ before\ this\ one.\n\ \ The\ method\ is\ finished\ when\ the\ method\ reaches\ the\ root\ of\ the\ tree\ and\ has\ heapified\ every\ \n\ \ nonleaf\ node\ in\ the\ tree.\ \n\ \ \n\ \ \n\ \ The\ time\ complexity\ is\ O(nlog(n)).\ \n\ \ @precondition\ heap\ is\ an\ array\ that\ contains\ the\ heap\ data\ for\ a\ complete\ binary\ tree\n\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ heapSize\ is\ less\ than\ the\ length\ of\ heap\ \n\ \ @postcondition\ the\ elements\ of\ heap\ have\ been\ rearranged\ such\ that\ heap\ \n\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ now\ contains\ the\ heap\ data\ for\ a\ max\ heap\n\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ heapSize\ is\ unchanged\ \n\ \ \n\ @param\ heap\ an\ array\ with\ the\ heap\ data\ for\ a\ complete\ binary\ tree\n\ \n\ @param\ heapSize\ the\ size\ of\ the\ heap\ \n\ \n
comment4.params=heap\ heapSize
comment4.target=java.lang.Comparable\ remove(java.lang.Comparable[],\ int)
comment4.text=\ The\ remove\ method\ removes\ the\ root\ of\ a\ complete\ binary\ tree\ by\ swapping\ with\ \n\ \ the\ last\ node\ in\ the\ tree\ and\ heapifying\ the\ swapped\ node.\ The\ root\ node\ is\ \n\ \ swapped\ with\ the\ last\ node\ in\ the\ heap\ and\ the\ size\ of\ the\ heap\ is\ then\ reduced\ by\ 1.\n\ \ The\ new\ value\ at\ the\ root\ of\ the\ true\ is\ then\ heapified\ and\ bubbled\ down\ to\ \n\ \ its\ correct\ place\ such\ that\ the\ tree\ follows\ the\ heap\ structure\ and\ max\ heap\ property.\ \n\ \ \n\ \ @precondition\ heap\ is\ an\ array\ that\ contains\ the\ heap\ data\ for\ a\ complete\ binary\ tree\n\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ heapSize\ is\ less\ than\ the\ length\ of\ heap\ \n\ \ @postcondition\ the\ elements\ of\ heap\ have\ been\ rearranged\ such\ that\ heap\ \n\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ now\ contains\ the\ heap\ data\ for\ a\ max\ heap\n\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ heapSize\ is\ decremented\ by\ 1\ \n\ \ The\ time\ complexity\ is\ O(log(n)).\ \n\n\ @param\ heap\ an\ array\ with\ the\ heap\ data\ for\ a\ complete\ binary\ tree\n\ \n\ @param\ heapSize\ the\ size\ of\ the\ heap\ \n\ @return\ the\ value\ that\ is\ removed\ \n\ \n
comment5.params=heap\ item\ heapSize
comment5.target=java.lang.Comparable[]\ insert(java.lang.Comparable[],\ java.lang.Comparable,\ int)
comment5.text=\ The\ insert\ method\ inserts\ a\ value\ into\ the\ complete\ binary\ tree.\ The\ element\ is\ added\ \n\ to\ the\ heap\ as\ the\ last\ element,\ and\ the\ value\ is\ bubbled\ up\ to\ the\ correct\ location\n\ \ such\ that\ the\ heap\ structure\ and\ the\ heap\ property\ are\ maintained.\ \n\ \ The\ time\ complexity\ is\ O(log(n)).\ \n\ \ @precondition\ heap\ is\ an\ array\ that\ contains\ the\ heap\ data\ for\ a\ complete\ binary\ tree\n\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ heapSize\ is\ less\ than\ the\ length\ of\ heap\ \n\ \ @postcondition\ the\ elements\ of\ heap\ have\ been\ rearranged\ such\ that\ heap\ \n\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ now\ contains\ the\ heap\ data\ for\ a\ max\ heap\n\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ heapSize\ is\ increased\ by\ 1\ \ \n\n\ @param\ heap\ an\ array\ with\ the\ heap\ data\ for\ a\ complete\ binary\ tree\n\ \n\ @param\ heapSize\ the\ size\ of\ the\ heap\ \n\ @param\ item\ the\ value\ of\ the\ new\ element\ to\ be\ inserted\ \n\ @return\ the\ array\ with\ the\ new\ value\ inserted\ in\ the\ appropriate\ location\ \n\ \n
comment6.params=heap\ heapSize
comment6.target=void\ heapSort(java.lang.Comparable[],\ int)
comment6.text=\ The\ heapSort\ method\ is\ an\ algorithm\ that\ sorts\ the\ elements\ in\ an\ array\ \n\ \ into\ ascending\ order.\ The\ algorithm\ works\ by\ converting\ the\ data\ set\ into\ a\ \n\ \ max\ Heap\ by\ calling\ buildHeap\ once.\n\ \ \n\ \ Then,\ it\ repeatedly\ removes\ the\ root\ of\ the\ tree\ and\ moves\ it\ \n\ \ to\ the\ end\ of\ the\ array\ until\ the\ heapSize\ is\ 1\ (by\ calling\ the\ delete\ method)\n\ \ and\ the\ elements\ of\ the\ array\ are\ in\ ascending\ order,\ all\ while\ maintaing\ \n\ \ the\ heap\ structure\ and\ property.\ \n\ \ The\ time\ complxity\ is\ O(nlogn).\ \n\ \ @precondition\ heap\ is\ an\ array\ that\ contains\ the\ heap\ data\ for\ a\ complete\ binary\ tree\n\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ heapSize\ is\ less\ than\ the\ length\ of\ heap\ \n\ \ @postcondition\ the\ elements\ of\ heap\ have\ been\ rearranged\ such\ that\ heap\ \n\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ now\ contains\ the\ heap\ data\ for\ a\ max\ heap\n\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ heapSize\ is\ unchanged\ \n\ @param\ heap\ an\ array\ with\ the\ heap\ data\ for\ a\ complete\ binary\ tree\n\ \n\ @param\ heapSize\ the\ size\ of\ the\ heap\ \n\ \n
comment7.params=array\ index1\ index2
comment7.target=java.lang.Comparable[]\ swapValues(java.lang.Comparable[],\ int,\ int)
comment7.text=\ The\ swapValues\ method\ swaps\ two\ values\ in\ an\ array.\ \ \n\ \ @postcondition\ the\ two\ values\ in\ the\ array\ are\ swapped\ \n\ \ @param\ array\ an\ array\ that\ contains\ the\ heap\ data\ \n\ \ @param\ index1\ the\ index\ of\ one\ element\ to\ be\ swapped\ \n\ \ @param\ index2\ the\ index\ of\ another\ element\ to\ be\ swapped\ \n\ \ @return\ the\ array\ with\ the\ two\ elements\ swapped\ \n\ \n
numComments=8
